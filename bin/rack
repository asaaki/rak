#!/usr/bin/env ruby

require 'getoptlong'

begin
  require 'rubygems'
  require 'oniguruma'
  require 'inline'
  $use_onig = true
rescue
  $use_onig = false
end

class Rack
  VERSION = "0.0.1"
  
  FILE_COLOUR = "\033[4m"
  MATCH_COLOUR = "\033[1m\033[31m"
  CLEAR_COLOURS = "\033[0m"
  
  VERSION_INFO=<<END
rack #{VERSION}

Copyright 2007 Daniel Lucraft, all rights reserved. 
Based on the perl tool 'ack' by Andy Lester.

This program is free software; you can redistribute it and/or modify it
under the same terms as Ruby.
END
  
  FILE_TYPES = {
        :asm         => %w( s S ),
   #     :binary      => q{Binary files, as defined by Perl's -B op (default: off)},
        :cc          => %w( c h xs ),
        :cpp         => %w( cpp m h C H ),
        :csharp      => %w( cs ),
        :css         => %w( css ),
        :elisp       => %w( el ),
        :haskell     => %w( hs lhs ),
        :hh          => %w( h ),
        :html        => %w( htm html shtml ),
     #   :skipped     => q{Files, but not directories, normally skipped by ack (default: off)},
        :lisp        => %w( lisp ),
        :java        => %w( java properties ),
        :js          => %w( js ),
        :jsp         => %w( jsp jspx jhtm jhtml ),
     #   :make        => q{Makefiles},
        :mason       => %w( mas mhtml mpl mtxt ),
        :ocaml       => %w( ml mli ),
        :parrot      => %w( pir pasm pmc ops pod pg tg ),
        :perl        => %w( pl pm pod t ),
        :php         => %w( php phpt php3 php4 php5 ),
        :python      => %w( py ),
        :ruby        => %w( rb rhtml rjs rxml ),
        :scheme      => %w( scm ),
        :shell       => %w( sh bash csh ksh zsh ),
        :sql         => %w( sql ctl ),
        :tcl         => %w( tcl ),
        :tex         => %w( tex cls sty ),
   #     :text        => q{Text files, as defined by Perl's -T op (default: off)},
        :tt          => %w( tt tt2 ttml ),
        :vb          => %w( bas cls frm ctl vb resx ),
        :vim         => %w( vim ),
        :yaml        => %w( yaml yml ),
        :xml         => %w( xml dtd xslt )
  }
  
  VC_DIRS = %w(blib CVS _darcs .git .pc RCS SCCS .svn)
  
  class << self
    attr_reader :opt
  end
  
  def self.search

    @opt = {}

    # file types
    opt[:includes] = []
    opt[:excludes] = []
    
    FILE_TYPES.each do |type, exts|
      if ARGV.delete('--'+type.to_s)
        exts.each do |ext|
          opt[:includes] << '.' + ext
        end
      end
      if ARGV.delete('--no'+type.to_s)
        exts.each do |ext|
          opt[:excludes] << '.' + ext
        end
      end
    end
    
    opts = GetoptLong.new(
      [ '--help', GetoptLong::NO_ARGUMENT ],
      [ '--max-count', '-m', GetoptLong::REQUIRED_ARGUMENT ],
      [ '--files', '-f', GetoptLong::NO_ARGUMENT ],
      [ '--output', GetoptLong::REQUIRED_ARGUMENT ],
      [ '--version', GetoptLong::NO_ARGUMENT ],
      [ '-c', GetoptLong::NO_ARGUMENT ],
      [ '-h', GetoptLong::NO_ARGUMENT ],
      [ '-i', GetoptLong::NO_ARGUMENT ],
      [ '-v', GetoptLong::NO_ARGUMENT ],
      [ '-n', GetoptLong::NO_ARGUMENT ],
      [ '-Q', GetoptLong::NO_ARGUMENT ],
      [ '-o', GetoptLong::NO_ARGUMENT ],
      [ '-w', GetoptLong::NO_ARGUMENT ],
      [ '--group', GetoptLong::NO_ARGUMENT ],
      [ '--nogroup', GetoptLong::NO_ARGUMENT ],
      [ '-l', GetoptLong::NO_ARGUMENT ],
      [ '-L', GetoptLong::NO_ARGUMENT ],
      [ '--passthru', GetoptLong::NO_ARGUMENT ],
      [ '-H', GetoptLong::NO_ARGUMENT ],
      [ '--colour', GetoptLong::NO_ARGUMENT ],
      [ '--nocolour', GetoptLong::NO_ARGUMENT ],
      [ '--color', GetoptLong::NO_ARGUMENT ],
      [ '--nocolor', GetoptLong::NO_ARGUMENT ],
      [ '-a', GetoptLong::NO_ARGUMENT ],
      [ '--type', GetoptLong::REQUIRED_ARGUMENT ]
    )

    dir = nil
    
    opt[:max_count] = nil
    opt[:do_search] = true
    opt[:print_filename] = true
    opt[:print_filelist] = false
    opt[:print_output] = nil
    opt[:print_highlighted] = true
    opt[:print_num_matches] = false
    opt[:ignore_case] = false
    opt[:invert_match] = false
    opt[:descend] = true
    opt[:literal] = false
    opt[:print_match] = false
    opt[:match_whole_words] = false
    opt[:print_file_each_line] = false
    opt[:print_file_if_match] = false
    opt[:print_file_if_no_match] = false
    opt[:print_entire_line_if_no_match] = false
    opt[:colour] = true
    opt[:all_files] = false
    
    opts.each do |option, arg|
      case option
      when '--help'
        puts DATA.read
        exit
      when '--max-count'
        opt[:max_count] = arg.to_i
      when '--files'
        opt[:do_search] = false
        opt[:print_filelist] = true
      when '--output'
        opt[:print_filename] = false
        opt[:print_output] = arg
        opt[:print_highlighted] = false
      when '--version'
        puts VERSION_INFO
        exit
      when '-c'
        opt[:print_num_matches] = true
        opt[:print_filename] = false
        opt[:print_highlighted] = false
      when '-h'
        opt[:print_filename] = false
      when '-i'
        opt[:ignore_case] = true
      when '-v'
        opt[:invert_match] = true
      when '-n'
        opt[:descend] = false
      when '-Q'
        opt[:literal] = true
      when '-o'
        opt[:print_match] = true
        opt[:print_filename] = false
        opt[:print_highlighted] = false
      when '-w'
        opt[:match_whole_words] = true
      when '--group'
        opt[:print_filename] = true
        opt[:print_file_each_line] = false
      when '--nogroup'
        opt[:print_file_each_line] = true
        opt[:print_filename] = false
      when '-l'
        opt[:print_filename] = false
        opt[:print_highlighted] = false
        opt[:print_file_if_match] = true
      when '-L'
        opt[:print_filename] = false
        opt[:print_highlighted] = false
        opt[:print_file_if_no_match] = true
      when '--passthru'
        opt[:print_entire_line_if_no_match] = true
      when '-H'
        opt[:print_filename] = true
      when '--nocolour', '--nocolor'
        opt[:colour] = false
      when '--colour', '--color'
        opt[:colour] = true
      when '-a'
        opt[:all_files] = true
      when '--type'
        if arg[0..1] == "no"
          type = arg[2..-1]
          arr = opt[:excludes]
        else
          type = arg
          arr = opt[:includes]
        end
        exts = FILE_TYPES[type.intern]
        exts.each do |ext|
          arr << '.' + ext
        end
      end
    end
    files = get_files
    
    unless opt[:colour]
      FILE_COLOUR.replace ""
      CLEAR_COLOURS.replace ""
      MATCH_COLOUR.replace ""
    end
    
    print_files(files)      if opt[:print_filelist]
    search2(ARGV[0], files) if opt[:do_search]
  end
  
  def self.print_files(files)
    files.each do |fn|
      puts fn
    end
  end
  
  def self.get_files(dir="./")
    types_files = FILE_TYPES.invert
    types = types_files.keys.flatten.map{|s| "."+s}
    if opt[:descend]
      glob = "**/*"
    else
      glob = "*"
    end
    
    files = Dir[dir+glob].select do |fn|
      File.file? fn
    end
    
    unless opt[:all_files]
      files = files.select do |fn|
        types.include? File.extname(fn)
      end
      files = files.select do |fn|
        fn[-1..-1] != "~" and
          fn[-1..-1] != "#"
      end
    end
    
    # reject version control dirs
    files.reject! do |fn|
      VC_DIRS.any? {|vc| fn.include? vc}
    end
    
    # select based on file type
    if not opt[:includes].empty?
      files = files.select do |fn|
        opt[:includes].include?(File.extname(fn))
      end
    end
    
    if not opt[:excludes].empty?
      files = files.select do |fn|
        not opt[:excludes].include?(File.extname(fn))
      end
    end
    
    # remove the "./"
    files.map{|fn| fn[2..-1]}
  end
    
  def self.search2(str, files)
    if opt[:literal]
      str = Regexp.quote(str)
    end
    if opt[:match_whole_words]
      str = "\\b" + str + "\\b"
    end
    if $use_onig
      if opt[:ignore_case]
        re = Oniguruma::ORegexp.new(str, :options => Oniguruma::OPTION_IGNORECASE)
      else
        re = Oniguruma::ORegexp.new(str)
      end
    else
      if opt[:ignore_case]
        re = Regexp.new(str, Regexp::IGNORECASE)
      else
        re = Regexp.new(str)
      end
    end
    files.each do |fn| 
      match_file(re, fn)
    end
  end
  
  def self.match_file(re, fn)
    displayed_filename = false
    count = 0
    i = 0
    matches = []
    File.open(fn) do |f|
      f.each_line do |line|
        i += 1
        rest = line
        while md = re.match(rest)
          rest = md.post_match
          if opt[:print_output]
            matches << eval(opt[:print_output])
          else
            matches << md
          end
          if opt[:print_match]
            puts md.to_s
          end
          count += 1
        end
        if opt[:invert_match]
          if opt[:print_filename] 
            unless displayed_filename
              puts FILE_COLOUR + fn + CLEAR_COLOURS
              displayed_filename = true
            end
          end
          if matches.empty?
            if opt[:print_highlighted]
              if opt[:print_filename]
                print "#{i}: "
              end
              puts "#{line}"
            end
          end
          matches.clear
        else
          if matches.empty?
            if opt[:print_entire_line_if_no_match]
              puts line
            end
          else
            if opt[:print_filename]
              unless displayed_filename
                puts FILE_COLOUR + fn + CLEAR_COLOURS
                displayed_filename = true
              end
            end
            if opt[:print_output]
              matches.each {|m| puts m}
            end
            if opt[:print_highlighted]
              if opt[:print_filename]
                prefix = "#{i}: "
              else
                if opt[:print_file_each_line]
                  prefix = FILE_COLOUR + "#{fn}" + CLEAR_COLOURS + " #{i}: "
                else
                  prefix = ""
                end
              end
              print_highlighted(prefix, line, matches)
            end
          end
          if opt[:max_count] 
            if count >= opt[:max_count]
              break
            end
          end
          matches.clear
        end
      end
      if opt[:print_highlighted] and opt[:print_filename]
        if count > 0
          puts
        end
      end
    end
    if opt[:print_num_matches]
      if opt[:invert_match]
        puts "#{fn}:#{i-count}"
      else
        puts "#{fn}:#{count}"
      end
    end
    if opt[:print_file_if_match]
      if count > 0
        puts fn
      end
    end
    
    if opt[:print_file_if_no_match]
      if count == 0
        puts fn
      end
    end
  end
  
  def self.print_highlighted(prefix, line, matches)
    from1 = matches[0].begin
    pre = ""
    pre = line[0..(from1-1)] if from1 > 0
    print prefix
    print pre
    ptr = 0
    0.upto(matches.length-1) do |n|
      from = matches[n].begin
      to   = matches[n].end
      print MATCH_COLOUR +
        line[(from+ptr)..(to+ptr-1)] +
        CLEAR_COLOURS
      ptr += to
      if n == matches.length - 1
        puts matches.last.post_match
      else
        print line[ptr..(matches[n+1].begin-1+ptr)]
      end
    end
  end
end

Rack.search

__END__
Usage: rack [OPTION]... PATTERN [FILES]

Search for PATTERN in each source file in the tree from cwd on down.
If [FILES] is specified, then only those files/directories are checked.
ack may also search STDIN, but only if no FILES are specified, or if
one of FILES is "-".

Default switches may be specified in ACK_OPTIONS environment variable.

Example: rack -i select

Searching:
  -i, --ignore-case     Ignore case distinctions
  -v, --invert-match    Invert match: select non-matching lines
  -w, --word-regexp     Force PATTERN to match only whole words
  -Q, --literal         Quote all metacharacters; expr is literal

Search output:
  -l, --files-with-matches
                        Only print filenames containing matches
  -L, --files-without-match
                        Only print filenames with no match
  -o                    Show only the part of a line matching PATTERN
                        (turns off text highlighting)
  --passthru            Print all lines, whether matching or not
  --output=expr         Output the evaluation of expr for each line
                        (turns off text highlighting)
  -m, --max-count=NUM   Stop searching in a file after NUM matches
  -H, --with-filename   Print the filename for each match
  -h, --no-filename     Suppress the prefixing filename on output
  -c, --count           Show number of lines matching per file

  --group               Group matches by file name.
                        (default: on when used interactively)
  --nogroup             One result per line, including filename, like grep
                        (default: on when the output is redirected)

  --[no]colour          Highlight the matching text (default: on unless
                        output is redirected, or on Windows)

File finding:
  -f                    Only print the files found, without searching.
                        The PATTERN must not be specified.
#  -g=REGEX              Same as -f, but only print files matching REGEX.
#  --sort-files          Sort the found files lexically.

File inclusion/exclusion:
  -n                    No descending into subdirectories
  -a, --all             All files, regardless of extension (but still skips
                        blib, CVS, _darcs, .git, .pc, RCS, SCCS and .svn dirs)
  --ruby                Include only Ruby files.
  --type=ruby           Include only Ruby files.
  --noruby              Exclude Ruby files.
  --type=noruby         Exclude Ruby files.
                        See "ack --help type" for supported filetypes.
#  --[no]follow          Follow symlinks.  Default is off.

Miscellaneous:
  --help                This help
  --version             Display version & copyright

